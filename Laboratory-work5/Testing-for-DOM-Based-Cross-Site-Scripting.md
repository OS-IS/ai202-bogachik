# Тестування міжсайтового сценарію на основі DOM

|ID|
|:---:|
|WSTG-CLNT-01|

## Конспект

[Міжсайтовий сценарій на основі DOM](https://owasp.org/www-community/attacks/DOM_Based_XSS) — це фактична назва помилок [XSS](https://owasp.org/www-community/attacks/xss/), які є результатом активного вмісту на стороні браузера на сторінці, як правило, JavaScript, отримання введених даних користувача через [джерело](https://github.com/wisec/domxsswiki/wiki/sources) та використання їх у [приймачі](https://github.com/wisec/domxsswiki/wiki/sources), що призводить до виконання введеного коду. У цьому документі розглядаються лише помилки JavaScript, які призводять до XSS.

DOM, або [об’єктна модель документа](https://en.wikipedia.org/wiki/Document_Object_Model), — це структурний формат, який використовується для представлення документів у браузері. DOM дозволяє динамічним сценаріям, таким як JavaScript, посилатися на такі компоненти документа, як поле форми або сеансовий файл cookie. DOM також використовується браузером для безпеки - наприклад, щоб обмежити сценарії в різних доменах від отримання файлів cookie сеансу для інших доменів. Уразливість XSS на основі DOM може виникнути, коли активний вміст, як-от функція JavaScript, змінюється спеціально створеним запитом, щоб елемент DOM міг контролювати зловмисник.

Не всі помилки XSS вимагають від зловмисника контролю над вмістом, що повертається із сервера, але натомість він може зловживати поганими методами кодування JavaScript для досягнення тих самих результатів. Наслідки такі ж, як і типовий недолік XSS, тільки засоби доставки відрізняються.

У порівнянні з іншими типами вразливостей міжсайтових сценаріїв ([відображених і збережених](https://owasp.org/www-community/attacks/xss/), коли сервер передає необроблений параметр, а потім повертає користувачеві та виконується в контексті веб-переглядача користувача), уразливість XSS на основі DOM контролює потік коду за допомогою елементів об’єктної моделі документа (DOM) разом із кодом, створеним зловмисником для зміни потоку.

Через свою природу XSS-уразливості на основі DOM можуть бути виконані в багатьох випадках без можливості сервера визначити, що насправді виконується. Це може зробити багато загальних методів фільтрації та виявлення XSS неефективними для таких атак.

У цьому гіпотетичному прикладі використовується наступний клієнтський код:

> `<script> document.write("Site is at: " + document.location.href + "."); </script>`

Зловмисник може додати ***#<script>alert('xss')</script>*** до URL-адреси ураженої сторінки, що під час виконання відобразить вікно сповіщення. У цьому випадку доданий код не буде надіслано на сервер, оскільки все після символу # браузер розглядає не як частину запиту, а як фрагмент. У цьому прикладі код негайно виконується, а на сторінці відображається сповіщення «xss». На відміну від більш поширених типів міжсайтового сценарію (відображеного та збереженого, у якому код надсилається на сервер, а потім назад у браузер, цей сценарій виконується безпосередньо в браузері користувача без звернення до сервера).

Наслідки недоліків XSS на основі DOM такі ж різноманітні, як і в більш відомих формах XSS, включаючи отримання файлів cookie, подальше впровадження зловмисного сценарію тощо, тому до них слід ставитися з такою ж суворістю.

## Цілі тесту
* Визначте приймачі DOM.
* Створюйте корисні навантаження, які стосуються кожного типу приймача.

## Як тестувати

Програми JavaScript суттєво відрізняються від інших типів програм, оскільки вони часто динамічно генеруються сервером. Щоб зрозуміти, який код виконується, веб-сайт, що тестується, потрібно просканувати, щоб визначити всі екземпляри виконання JavaScript і місця, де приймається введення користувача. Багато веб-сайтів покладаються на великі бібліотеки функцій, які часто охоплюють сотні тисяч рядків коду й не розроблялися власними силами. У цих випадках низхідне тестування часто стає єдиним життєздатним варіантом, оскільки багато функцій нижнього рівня ніколи не використовуються, і їх аналіз, щоб визначити, які є поглиначами, займе більше часу, ніж зазвичай доступно. Те ж саме можна сказати про тестування зверху вниз, якщо вхідні дані або їх відсутність не ідентифіковано з самого початку.

Введення користувача здійснюється у двох основних формах:

* Вхідні дані, записані на сторінку сервером у спосіб, який не дозволяє прямий XSS, і
* Вхідні дані, отримані від клієнтських об’єктів JavaScript.

Ось два приклади того, як сервер може вставляти дані в JavaScript:

> `var data = "<екрановані дані з сервера>";`
>
> `var result = someFunction("<екрановані дані з сервера>");`

Ось два приклади введення з клієнтських об’єктів JavaScript:

> `var data = window.location;`
>
> `var result = someFunction(window.referrer);`

Незважаючи на те, що код JavaScript не має великої різниці в тому, як вони витягуються, важливо зазначити, що коли вхідні дані надходять через сервер, сервер може застосувати будь-які зміни до даних, які йому потрібні. З іншого боку, перестановки, які виконуються об’єктами JavaScript, досить добре зрозумілі та задокументовані. Якби ***someFunction*** у наведеному вище прикладі була приймачем, тоді можливість використання в першому випадку залежала б від фільтрації, виконаної сервером, тоді як в останньому випадку це залежало б від кодування, виконаного браузером для об’єкта ***window.referrer***. Стефано Ді Пауло написав чудову статтю про те, що повертають браузери, коли запитують різні елементи [URL-адреси за допомогою атрибутів документа та розташування](https://github.com/wisec/domxsswiki/wiki/location,-documentURI-and-URL-sources).

Крім того, JavaScript часто виконується поза блоками ***<script>***, про що свідчать численні вектори, які в минулому призводили до обходу фільтрів XSS. Під час сканування програми важливо звернути увагу на використання сценаріїв у таких місцях, як обробники подій і блоки CSS з атрибутами виразів. Також зауважте, що будь-які сторонні CSS або об’єкти сценаріїв потрібно буде оцінити, щоб визначити, який код виконується.

Автоматизоване тестування має дуже обмежений успіх у ідентифікації та перевірці XSS на основі DOM, оскільки воно зазвичай ідентифікує XSS, надсилаючи певне корисне навантаження та намагаючись спостерігати його у відповіді сервера. Це може добре працювати для простого прикладу, наведеного нижче, де параметр повідомлення відображається назад до користувача:

> `<script>`
> 
> `var pos=document.URL.indexOf("message=")+5;`
> 
> `document.write(document.URL.substring(pos,document.URL.length));`
> 
> `</script>`

Однак його можна не виявити в наступному надуманому випадку:

> `<script>`
> 
> `var navAgt = navigator.userAgent;`
> 
> `if (navAgt.indexOf("MSIE")!=-1)`
>
> `{`
> 
> `        document.write("You are using IE as a browser and visiting site: " + document.location.href + ".");`
> 
> `}`
> 
> `else`
> 
> `{`
> 
> `    document.write("You are using an unknown browser.");`
> 
> `}`
> 
> `</script>`

## Заходи запобігання
Щоб дізнатися про заходи щодо запобігання XSS на основі DOM, див. [DOM-based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).

## Посилання
* [DomXSSWiki](https://github.com/wisec/domxsswiki/wiki/)
* [Стаття DOM XSS від Аміта Кляйна](http://www.webappsec.org/projects/articles/071105.html)

